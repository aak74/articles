# Пользователь в Docker
Если специальным образом не указать пользователя, под которым будут работать процессы в контейнере, то все процессы будут работать из под пользователя root. Это очень удобно, ведь у этого пользователя нет никаких ограничений. И именно поэтому работать под рутом неправильно с точки зрения безопасности. И если на локальном компьютере никто в здравом уме не работает с рутовыми правами, то многие запускают процессы в контейнерах под рутом.

Всегда есть баги, которые могут позволить зловреду выбраться из контейнера и попасть на хостовый компьютер. Предполагая худшее мы должны обеспечить запуск процессов внутри контейнера от пользователя, который не имеет никаких прав на хостовой машине.

## Создание пользователя
Создание пользователя в контейнере не отличается от его создания в линуксовых дистрибутивах.
Однако для разных базовых образов команды могут различаться.

Для дистрибутивов основанных на debian в Dockerfile необходимо добавить следующее:
```Dockerfile
RUN groupadd --gid 2000 node \
  && useradd --uid 2000 --gid node --shell /bin/bash --create-home node
```

Для alpine:
```Dockerfile
RUN addgroup -g 2000 node \
    && adduser -u 2000 -G node -s /bin/sh -D node
```

## Запуск процессов от пользователя
Для запуска всех последующих процессов от пользователя с UID 2000 выполните следующее:
```Dockerfile
USER 2000
```
Для запуска всех последующих процессов от пользователя `node` выполните следующее:
```Dockerfile
USER node
```
Подробнее в [документации](https://docs.docker.com/engine/reference/builder/#user)

## Монтирование томов
При монтирование томов внутрь контейнера необходимо обеспечить пользователю возможность читать и (или) писать файлы. Для этого необходимо обеспечить соответствие UID (GID) пользователя в контейнере и пользователя за пределами контейнера, у которого есть соответствующие права на доступ к файлам. При этом имена пользователей не имеют никакого значения.

Часто на линуксовом компьютере у пользователя UID и GID равны 1000. Эти идентификаторы присваиваются первому пользователю компьютера.

Узнать свои идентификаторы просто:
```sh
id
```
Вы получите исчерпывающую информацию о своем пользователе.

Замените 2000 из примеров на свой идентификатор и все будет в порядке.

## Присвоение пользователю UID и GID
Если пользователь создан ранее, но необходимо изменить идентификаторы то можно сделать это так:
```Dockerfile
RUN usermod -u 1000 www-data \
  && groupmod -g 1000 www-data
```

Если вы используете базовый образ alpine, то нужно установить пакет `shadow`:
```Dockerfile
RUN apk add --no-cache shadow
```

## Передача идентификатора пользователя внутрь контейнера при построении образа
Если ваш идентификатор и идентификаторы всех людей, которые работают над проектом совпадают, то достаточно указать этот идентификатор в Dockerfile. Однако часто идентификаторы пользователей не совпадают.

Как осуществить желаемое не сразу понятно. Для меня это было самым сложным в процессе освоения docker.
Многие пользователи docker не задумываются о том, что есть разные этапы жизни образа. Сначала собирается образ для этого используется Dockerfile. При запуске контейнера из образа Dockerfile уже не используется.

Создание пользователей должно происходить при построении образа. Это же касается и определения пользователя из под которого запускаются процессы. А это значит, что мы каким-то образом должны передать внутрь контейнера UID (GID).

Для использования внешних переменных в Dockerfile служат директивы [ENV](https://docs.docker.com/engine/reference/builder/#env) и [ARG](https://docs.docker.com/engine/reference/builder/#arg).
Подробное сравнение директив [тут](https://vsupalov.com/docker-arg-env-variable-guide/).

Dockerfile
```Dockerfile
ARG UID=1000
ARG GID=1000
ENV UID=${UID}
ENV GID=${GID}
RUN usermod -u $UID node \
  && groupmod -g $GID node
```

Передать аргументы через docker-compose можно так:
docker-compose
```yaml
build:
  context: ./src/backend
  args:
    UID: 1000
    GID: 1000
```

P.S. Для освоения всех премудростей docker недостаточно читать документацию или статьи. Нужно много практиковаться, нужно почувствовать docker.